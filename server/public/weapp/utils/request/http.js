"use strict";var e=Object.defineProperty,t=(t,s,r)=>(((t,s,r)=>{s in t?e(t,s,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[s]=r})(t,"symbol"!=typeof s?s+"":s,r),r);const s=require("../../common/vendor.js"),r=require("../../enums/requestEnums.js"),o=require("./cancel.js");exports.HttpRequest=class{constructor(e){t(this,"options"),this.options=e}retryRequest(e,t){var o;const{retryCount:n,retryTimeout:u}=t;return n&&(null==(o=e.method)?void 0:o.toUpperCase())!=r.RequestMethodsEnum.POST?(s.index.showLoading({title:"加载中..."}),t.hasRetryCount=t.hasRetryCount||0,t.hasRetryCount>=n?Promise.reject():(t.hasRetryCount++,t.requestHooks.requestInterceptorsHook=e=>e,new Promise((e=>setTimeout(e,u))).then((()=>this.request(e,t))).finally((()=>s.index.hideLoading())))):Promise.reject()}get(e,t){return this.request({...e,method:r.RequestMethodsEnum.GET},t)}post(e,t){return this.request({...e,method:r.RequestMethodsEnum.POST},t)}eventStream(e,t){let r=s.merge({},this.options.requestOptions,e);const o=s.merge({},this.options,t),{requestInterceptorsHook:n,responseInterceptorsHook:u}=o.requestHooks||{};n&&s.isFunction(n)&&(r=n(r,o));const{onmessage:i,onclose:a,onstart:c}=o;return new Promise(((e,t)=>{try{let n={};const l=s.index.request({...r,enableChunked:!0,responseType:"arraybuffer",async success(s){200===s.statusCode?e(s):t(s)},fail(e){t(e)},complete(){null==a||a()}});null==c||c(l),l.onHeadersReceived((e=>{n=e.header})),l.onChunkReceived((async a=>{const c=a.data,l=function(e){let t="";for(let s=0;s<e.length;s++)t+=String.fromCharCode(e[s]);return decodeURIComponent(escape(t))}(new Uint8Array(c));if("string"==typeof(p=n["Content-Type"])&&p.includes("text/event-stream"))null==i||i(l);else{const n=JSON.parse(l);if(u&&s.isFunction(u)){try{const t=await u({data:n,statusCode:200},o,r);e(t)}catch(d){t(d)}return}}var p}))}catch(n){t()}}))}uploadFile(e,t){let o=s.merge({},this.options.requestOptions,e);const n=s.merge({},this.options,t),{requestInterceptorsHook:u,responseInterceptorsHook:i,responseInterceptorsCatchHook:a}=n.requestHooks||{};return u&&s.isFunction(u)&&(o=u(o,n)),new Promise(((e,t)=>{s.index.uploadFile({...o,header:{...o.header},async success(r){if(200==r.statusCode){if(r.data=JSON.parse(r.data),i&&s.isFunction(i)){try{r=await i(r,n,o),e(r)}catch(u){t(u)}return}e(r)}else t(r.errMsg)},fail(e){e.errMsg!=r.RequestErrMsgEnum.ABORT&&(a&&s.isFunction(a)?t(a(o,e)):t(e.errMsg||e))}}).onProgressUpdate((({progress:e})=>{var t;null==(t=n.onProgress)||t.call(n,e)}))}))}async request(e,t){let n=s.merge({},this.options.requestOptions,e);const u=s.merge({},this.options,t),{requestInterceptorsHook:i,responseInterceptorsHook:a,responseInterceptorsCatchHook:c}=u.requestHooks||{};return i&&s.isFunction(i)&&(n=i(n,u)),new Promise(((t,i)=>{const l=s.index.request({...n,async success(e){if(200!==e.statusCode)return i();if(a&&s.isFunction(a))try{e=await a(e,u,n),t(e)}catch(r){i(r)}else t(e)},fail:async e=>{e.errMsg!=r.RequestErrMsgEnum.TIMEOUT?e.errMsg!=r.RequestErrMsgEnum.ABORT&&(c&&s.isFunction(c)?i(await c(n,e)):i(e)):this.retryRequest(n,u).then((e=>t(e))).catch((e=>i(e)))},complete(t){t.errMsg!==r.RequestErrMsgEnum.ABORT&&o.requestCancel.remove(e.url)}}),{ignoreCancel:p}=u;!p&&o.requestCancel.add(e.url,l)}))}};
